#summary using pygr to develop an Ensembl API

= Introduction =

The Ensembl database system is a central data repository for various eukaryotic genome sequences and their annotated information [http://www.ensembl.org Ensembl Home].  The screenshots of schema diagrams for the four basic types of databases (core, compara, variation and funcgen) can be found at: [http://groups.google.com/group/pygr-dev/files?hl=en pygr-dev files].  They were created using the files in the sql/
directory of the ensembl CVS module. The [http://pygr-dev.googlegroups.com/web/table.sql?gda=M3ILbjoAAABJgcRQ_B738LYip0lXSox5BrGVnIRWNUQzXUPZ5KyWuGG1qiJ7UbTIup-M2XPURDTDvhSABxKrnfEc_FGQElaK table.sql] file gives the table
definitions and the [http://pygr-dev.googlegroups.com/web/foreign_keys.sql?gda=K02TckEAAABJgcRQ_B738LYip0lXSox5BrGVnIRWNUQzXUPZ5KyWuGG1qiJ7UbTIup-M2XPURDRvOefWPvoIMlEIkd9UdRbQLTxVVTd9FLrlvrrz00ZndA foreign_keys.sql] gives the foreign key definitions.  Being able to access its numerous large databases efficiently is indispensable to any genome research project. Currently, the Ensembl databases are mostly accessed through a Perl API or a (less developed) Java API. No equivalent Python API is yet available.

This project [http://code.google.com/soc/2008/psf/appinfo.html?csaid=16FD71A42C4B7B GSoC 2008] aims to develop a Python API to access the Ensembl databases, using pygr.  Pygr is a Python database interface framework for bioinformatics that
makes it easy to supply a pythonic interface to genome, annotation and
alignment databases such as Ensembl.  

By developing a Python Ensembl API, we hope to encourage the use of Python for programming in the field of Bioinfomatics.

= How will pygr make the development easier? =

The key advantages of choosing pygr over many other ORMs (object relational mappers, such as SqlAlchemy) are the followings:

*1.* it provides highly pythonic models for bioinformatics data based on
familiar Python constructs such as the mapping protocol (dictionaries) and sequence protocol; 

*2.* these consistent interfaces allow the same client code to work transparently with many different "backend" implementations for how the data is actually stored;

*3.* the client code is insulated from the complexities of back-end database queries; 

*4.* pygr works with a wide variety of backend storage systems that provide tremendous scalability for challenging bioinformatics database problems such as terabyte-size multigenome alignments;

*5.* pygr provides strong support for modeling database schemas, and greatly simplifies the problem of accessing and distributing complex database schemas (it transforms them into an "importable" python namespace).

These core capabilities will allow us to focus on problems that are
truly specific to the Ensembl data, rather than general
infrastructure, while delivering a solution that will be much easier
for bioinformatics researchers to use.

= Implementation Details =

Currently, we are in the process of trying pygr to access the dna and exon tables of the ensembl core database and build bi-directional mappings between the genome and the annotation.  For more information, please refer to the following thread [http://groups.google.com/group/pygr-dev/browse_thread/thread/5d55fd9d071fbf4d?hl=en]. 

Stay tuned for further progress reports from us :)  

= Approach =

Due to limited time frame, I am going to take on a minimalist approach in the first round, and then progressively add more functionality and features to the basic version. 

= Requirements Specification =

Glenn Proctor, the head of the ensembl software team, kindly recommended some
tasks that a minimalist API should allow the user to perform, e.g.

*-* obtain the DNA sequence of a particular genomic region (defined by
chromosome, start, end, strand)

*-* find all the genes in a genomic region, and their transcripts and
translations

*-* retrieve all the genes that are associated with a particular
external reference, e.g. an HGNC symbol or GO term


= Design Decisions =

*Scope*

For now, the primary focus of this API is to provide means to retrieve information from the ensembl core databases.  

*Framework*

*1.* the datamodel module [http://pygr-dev.googlegroups.com/web/datamodel.py?hl=en%253A&gsc=SDO_owsAAADv9zjLtj_JuEWS1q7AkBzo datamodel.py]: a BaseModel super class and its subclasses.  Each subclass represents a biological entity.

*2.* the adaptor module [http://pygr-dev.googlegroups.com/web/adaptor.py?hl=en%253A adaptor.py]: a driver class, a generic adaptor class (super class) and many specialized adaptor classes (sub classes).  Each specialized adaptor class employs pygr modules (mainly the sqlgraph and seqdb module) and provides access to its corresponding sql table in an ensembl core database.

*3.* the supporting module (seqregion.py): extensions of the pygr core modules.

*Design Pattern*

The Driver class in the adaptor module is implemented as a singleton class, since making a connection to the database is expensive.

= Implemented Functionality =

The current ensembl API allows the user to perform the following tasks:

*1.* obtain the DNA sequence of a particular genomic region (defined by chromosome, start, end and strand)

  feature method in adaptor.py:

  - Driver: `fetch_sequence_by_region(chromosome, start, end, strand)`

*2.* find all the exons, genes and transcripts in a genomic region

  feature methods in adaptor.py:

  - ExonAdaptor: `fetch_exons_by_seqregion(chromosome, start, end, strand, driver)`

  - GeneAdaptor: `fetch_genes_by_seqregion(chromosome, start, end, strand, driver)`

  - TranscriptAdaptor: `fetch_transcripts_by_seqregion(chromosome, start, end, strand, driver)`

*3.* given a gene, obtain its transcripts, exons and translations

  feature method in datamodel.py:

  - Gene: `getTranscripts()`, `getExons()`, `getTranslations()`

  - Transcript: `getExons()`

  - Translation: `getExons()`

  feature method in adaptor.py:

  - TranscriptAdaptor: `fetch_transcripts_by_geneID(gene_id)`

  - ExonAdaptor: `fetch_exons_by_transcriptID(transcript_id)`, `fetch_exons_by_translation(transcript_id, start_exon_id, end_exon_id)`

  - TranslationAdaptor: `fetch_translations_by_transcriptID(transcript_id)`

*4.* given an external reference label, retrieve all the associated genes

  feature method in adaptor.py:

  - GeneAdaptor: `fetch_genes_by_externalRef(external_ref_label)`  


*5.* obtain the DNA sequence of a particular sliceable object (such as a gene, a transcript or an exon)

  feature method in datamodel.py:

  - Sliceable: `getSequence(table_name)`
             	    
*6.* obtain a column-value attribute associated with a table-record object

= Updates =

*1.* mini-release upgraded to v0.03 

ensemblv0.03.tar.gz at [http://groups.google.com/group/pygr-dev/files?hl=en: pygr-dev files] (running environment: the latest pygr.  For detailed information on how to get a copy of it, please go to [http://code.google.com/p/pygr/wiki/ViewSource ViewSouce])

Alternatively, the current ensembl API code, together with pygr, can be retrieved from the public git repository.  To check out a copy, run the following instruction on the command line:

`git clone git://iorich.caltech.edu/git/public/pygr-jenny <dirname of your choice>`

(More information on Git can be found at [http://code.google.com/p/pygr/wiki/UsingGit UsingGit])

*2.* the test output files

They provide a preliminary test outcome for the functions implemented.

[http://pygr-dev.googlegroups.com/web/testdatamodel.out?hl=en%253A: testdatamodel.out] from running the sample code in datamodel.py, which gives a test result for the functions implemented in each specialized Datamodel class. 

[http://pygr-dev.googlegroups.com/web/testadaptor.out?hl=en%253A: testadaptor.out] from running the sample code in adaptor.py, which gives a test result for the functions implemented in the Driver class and in each specialized Adaptor class.